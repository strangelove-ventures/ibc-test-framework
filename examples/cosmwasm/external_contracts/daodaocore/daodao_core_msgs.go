/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */
package daodaocore

type InstantiateMsg struct {
	// An image URL to describe the core module contract.
	ImageUrl *string `json:"image_url,omitempty"`
	/*
	   The items to instantiate this DAO with. Items are arbitrary key-value pairs whose contents are controlled by governance.

	   It is an error to provide two items with the same key.
	*/
	InitialItems []InitialItem `json:"initial_items"`
	// The name of the core contract.
	Name string `json:"name"`
	// Instantiate information for the core contract's proposal modules. NOTE: the pre-propose-base package depends on it being the case that the core module instantiates its proposal module.
	ProposalModulesInstantiateInfo []ModuleInstantiateInfo `json:"proposal_modules_instantiate_info"`
	// Instantiate information for the core contract's voting power module.
	VotingModuleInstantiateInfo ModuleInstantiateInfo `json:"voting_module_instantiate_info"`
	// If true the contract will automatically add received cw721 tokens to its treasury.
	AutomaticallyAddCw721S bool `json:"automatically_add_cw721s"`
	// If true the contract will automatically add received cw20 tokens to its treasury.
	AutomaticallyAddCw20S bool `json:"automatically_add_cw20s"`
	// Implements the DAO Star standard: <https://daostar.one/EIP>
	DaoUri *string `json:"dao_uri,omitempty"`
	// A description of the core contract.
	Description string `json:"description"`
	// Optional Admin with the ability to execute DAO messages directly. Useful for building SubDAOs controlled by a parent DAO. If no admin is specified the contract is set as its own admin so that the admin may be updated later by governance.
	Admin *string `json:"admin,omitempty"`
}

type ExecuteMsg struct {
	// Callable by the Admin, if one is configured. Executes messages in order.
	ExecuteAdminMsgs *ExecuteMsg_ExecuteAdminMsgs `json:"execute_admin_msgs,omitempty"`
	// Callable by proposal modules. The DAO will execute the messages in the hook in order.
	ExecuteProposalHook *ExecuteMsg_ExecuteProposalHook `json:"execute_proposal_hook,omitempty"`
	// Pauses the DAO for a set duration. When paused the DAO is unable to execute proposals
	Pause *ExecuteMsg_Pause `json:"pause,omitempty"`
	// Unpauses the DAO
	Unpause *ExecuteMsg_Unpause `json:"unpause,omitempty"`
	// Executed when the contract receives a cw20 token. Depending on the contract's configuration the contract will automatically add the token to its treasury.
	Receive *ExecuteMsg_Receive `json:"receive,omitempty"`
	// Executed when the contract receives a cw721 token. Depending on the contract's configuration the contract will automatically add the token to its treasury.
	ReceiveNft *ExecuteMsg_ReceiveNft `json:"receive_nft,omitempty"`
	// Removes an item from the governance contract's item map.
	RemoveItem *ExecuteMsg_RemoveItem `json:"remove_item,omitempty"`
	// Adds an item to the governance contract's item map. If the item already exists the existing value is overridden. If the item does not exist a new item is added.
	SetItem *ExecuteMsg_SetItem `json:"set_item,omitempty"`
	/*
	   Callable by the admin of the contract. If ADMIN is None the admin is set as the contract itself so that it may be updated later by vote. If ADMIN is Some a new admin is proposed and that new admin may become the admin by executing the `AcceptAdminNomination` message.

	   If there is already a pending admin nomination the `WithdrawAdminNomination` message must be executed before a new admin may be nominated.
	*/
	NominateAdmin *ExecuteMsg_NominateAdmin `json:"nominate_admin,omitempty"`
	/*
	   Callable by a nominated admin. Admins are nominated via the `NominateAdmin` message. Accepting a nomination will make the nominated address the new admin.

	   Requiring that the new admin accepts the nomination before becoming the admin protects against a typo causing the admin to change to an invalid address.
	*/
	AcceptAdminNomination *ExecuteMsg_AcceptAdminNomination `json:"accept_admin_nomination,omitempty"`
	// Callable by the current admin. Withdraws the current admin nomination.
	WithdrawAdminNomination *ExecuteMsg_WithdrawAdminNomination `json:"withdraw_admin_nomination,omitempty"`
	// Callable by the core contract. Replaces the current governance contract config with the provided config.
	UpdateConfig *ExecuteMsg_UpdateConfig `json:"update_config,omitempty"`
	// Updates the list of cw20 tokens this contract has registered.
	UpdateCw20List *ExecuteMsg_UpdateCw20List `json:"update_cw20_list,omitempty"`
	// Updates the list of cw721 tokens this contract has registered.
	UpdateCw721List *ExecuteMsg_UpdateCw721List `json:"update_cw721_list,omitempty"`
	// Updates the governance contract's governance modules. Module instantiate info in `to_add` is used to create new modules and install them.
	UpdateProposalModules *ExecuteMsg_UpdateProposalModules `json:"update_proposal_modules,omitempty"`
	// Callable by the core contract. Replaces the current voting module with a new one instantiated by the governance contract.
	UpdateVotingModule *ExecuteMsg_UpdateVotingModule `json:"update_voting_module,omitempty"`
	// Update the core module to add/remove SubDAOs and their charters
	UpdateSubDaos *ExecuteMsg_UpdateSubDaos `json:"update_sub_daos,omitempty"`
}

type MigrateMsg struct {
	FromV1         *MigrateMsg_FromV1         `json:"from_v1,omitempty"`
	FromCompatible *MigrateMsg_FromCompatible `json:"from_compatible,omitempty"`
}

type QueryMsg struct {
	// Get's the DAO's admin. Returns `Addr`.
	Admin *QueryMsg_Admin `json:"admin,omitempty"`
	// Get's the currently nominated admin (if any).
	AdminNomination *QueryMsg_AdminNomination `json:"admin_nomination,omitempty"`
	// Gets the contract's config.
	Config *QueryMsg_Config `json:"config,omitempty"`
	// Gets the token balance for each cw20 registered with the contract.
	Cw20Balances *QueryMsg_Cw20Balances `json:"cw20_balances,omitempty"`
	// Lists the addresses of the cw20 tokens in this contract's treasury.
	Cw20TokenList *QueryMsg_Cw20TokenList `json:"cw20_token_list,omitempty"`
	// Lists the addresses of the cw721 tokens in this contract's treasury.
	Cw721TokenList *QueryMsg_Cw721TokenList `json:"cw721_token_list,omitempty"`
	// Dumps all of the core contract's state in a single query. Useful for frontends as performance for queries is more limited by network times than compute times.
	DumpState *QueryMsg_DumpState `json:"dump_state,omitempty"`
	// Gets the address associated with an item key.
	GetItem *QueryMsg_GetItem `json:"get_item,omitempty"`
	// Lists all of the items associted with the contract. For example, given the items `{ "group": "foo", "subdao": "bar"}` this query would return `[("group", "foo"), ("subdao", "bar")]`.
	ListItems *QueryMsg_ListItems `json:"list_items,omitempty"`
	// Returns contract version info
	Info *QueryMsg_Info `json:"info,omitempty"`
	// Gets all proposal modules associated with the contract.
	ProposalModules *QueryMsg_ProposalModules `json:"proposal_modules,omitempty"`
	// Gets the active proposal modules associated with the contract.
	ActiveProposalModules *QueryMsg_ActiveProposalModules `json:"active_proposal_modules,omitempty"`
	// Gets the number of active and total proposal modules registered with this module.
	ProposalModuleCount *QueryMsg_ProposalModuleCount `json:"proposal_module_count,omitempty"`
	// Returns information about if the contract is currently paused.
	PauseInfo *QueryMsg_PauseInfo `json:"pause_info,omitempty"`
	// Gets the contract's voting module.
	VotingModule *QueryMsg_VotingModule `json:"voting_module,omitempty"`
	// Returns all SubDAOs with their charters in a vec. start_after is bound exclusive and asks for a string address.
	ListSubDaos *QueryMsg_ListSubDaos `json:"list_sub_daos,omitempty"`
	// Implements the DAO Star standard: <https://daostar.one/EIP>
	DaoURI *QueryMsg_DaoURI `json:"dao_u_r_i,omitempty"`
	// Returns the voting power for an address at a given height.
	VotingPowerAtHeight *QueryMsg_VotingPowerAtHeight `json:"voting_power_at_height,omitempty"`
	// Returns the total voting power at a given block height.
	TotalPowerAtHeight *QueryMsg_TotalPowerAtHeight `json:"total_power_at_height,omitempty"`
}

type ExecuteMsg_RemoveItem struct {
	Key string `json:"key"`
}

type ExecuteMsg_UpdateVotingModule struct {
	Module ModuleInstantiateInfo `json:"module"`
}

/*
An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.

It is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)
*/
type Empty struct{}

/*
The message types of the staking module.

See https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto
*/
type StakingMsg struct {
	// This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90). `delegator_address` is automatically filled with the current contract's address.
	Delegate *StakingMsg_Delegate `json:"delegate,omitempty"`
	// This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121). `delegator_address` is automatically filled with the current contract's address.
	Undelegate *StakingMsg_Undelegate `json:"undelegate,omitempty"`
	// This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105). `delegator_address` is automatically filled with the current contract's address.
	Redelegate *StakingMsg_Redelegate `json:"redelegate,omitempty"`
}

type QueryMsg_AdminNomination struct{}

type QueryMsg_Cw721TokenList struct {
	Limit      *int    `json:"limit,omitempty"`
	StartAfter *string `json:"start_after,omitempty"`
}

// Returned by the `AdminNomination` query.
type AdminNominationResponse struct {
	// The currently nominated admin or None if no nomination is pending.
	Nomination *Addr `json:"nomination,omitempty"`
}

// Information needed to instantiate a module.
type ModuleInstantiateInfo struct {
	// CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>
	Admin *Admin `json:"admin,omitempty"`
	// Code ID of the contract to be instantiated.
	CodeId int `json:"code_id"`
	// Funds to be sent to the instantiated contract.
	Funds []Coin `json:"funds"`
	// Label for the instantiated contract.
	Label string `json:"label"`
	// Instantiate message to be used to create the contract.
	Msg Binary `json:"msg"`
}

/*
A point in time in nanosecond precision.

This type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.

## Examples

``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);

let ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```
*/
type Timestamp Uint64

type InfoResponse struct {
	Info ContractVersion `json:"info"`
}

type list_sub_daos []SubDao

type QueryMsg_Info struct{}

type QueryMsg_ListSubDaos struct {
	Limit      *int    `json:"limit,omitempty"`
	StartAfter *string `json:"start_after,omitempty"`
}

type VotingPowerAtHeightResponse struct {
	Height int     `json:"height"`
	Power  Uint128 `json:"power"`
}

// Top level type describing a proposal module.
type ProposalModule struct {
	// The status of the proposal module, e.g. 'Enabled' or 'Disabled.'
	Status ProposalModuleStatus `json:"status"`
	// The address of the proposal module.
	Address Addr `json:"address"`
	// The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.
	Prefix string `json:"prefix"`
}

// Returned by the `Cw20Balances` query.
type Cw20BalanceResponse struct {
	// The address of the token.
	Addr Addr `json:"addr"`
	// The contract's balance.
	Balance Uint128 `json:"balance"`
}

// Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.
type Admin struct {
	// Set the admin to a specified address.
	Address *Admin_Address `json:"address,omitempty"`
	// Sets the admin as the core module address.
	CoreModule *Admin_CoreModule `json:"core_module,omitempty"`
}

/*
The message types of the bank module.

See https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto
*/
type BankMsg struct {
	/*
	   Sends native tokens from the contract to the given address.

	   This is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28). `from_address` is automatically filled with the current contract's address.
	*/
	Send *BankMsg_Send `json:"send,omitempty"`
	// This will burn the given coins from the contract's account. There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper. Important if a contract controls significant token supply that must be retired.
	Burn *BankMsg_Burn `json:"burn,omitempty"`
}

type VoteOption string

const (
	VoteOption_Yes        VoteOption = "yes"
	VoteOption_No         VoteOption = "no"
	VoteOption_Abstain    VoteOption = "abstain"
	VoteOption_NoWithVeto VoteOption = "no_with_veto"
)

type V2CodeIds struct {
	Cw20Stake                int `json:"cw20_stake"`
	Cw20StakedBalancesVoting int `json:"cw20_staked_balances_voting"`
	Cw4Voting                int `json:"cw4_voting"`
	ProposalSingle           int `json:"proposal_single"`
}

type QueryMsg_Cw20Balances struct {
	StartAfter *string `json:"start_after,omitempty"`
	Limit      *int    `json:"limit,omitempty"`
}

type QueryMsg_ActiveProposalModules struct {
	StartAfter *string `json:"start_after,omitempty"`
	Limit      *int    `json:"limit,omitempty"`
}

type ExecuteMsg_SetItem struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type QueryMsg_ProposalModuleCount struct{}

// Information about if the contract is currently paused.
type pause_info struct {
	Paused   *pause_info_Paused   `json:"paused,omitempty"`
	Unpaused *pause_info_Unpaused `json:"unpaused,omitempty"`
}
type ExecuteMsg_ReceiveNft Cw721ReceiveMsg

type ExecuteMsg_UpdateCw721List struct {
	ToAdd    []string `json:"to_add"`
	ToRemove []string `json:"to_remove"`
}

/*
This message type allows the contract interact with the [x/gov] module in order to cast votes.

## Examples

Cast a simple vote:

``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); use cosmwasm_std::{GovMsg, VoteOption};

#[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::Vote { proposal_id: 4, vote: VoteOption::Yes, })) } ```

Cast a weighted vote:

``` # use cosmwasm_std::{ #     HexBinary, #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo, #     Response, QueryResponse, # }; # type ExecuteMsg = (); # #[cfg(feature = "cosmwasm_1_2")] use cosmwasm_std::{Decimal, GovMsg, VoteOption, WeightedVoteOption};

# #[cfg(feature = "cosmwasm_1_2")] #[entry_point] pub fn execute( deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg, ) -> Result<Response, StdError> { // ... Ok(Response::new().add_message(GovMsg::VoteWeighted { proposal_id: 4, options: vec![ WeightedVoteOption { option: VoteOption::Yes, weight: Decimal::percent(65), }, WeightedVoteOption { option: VoteOption::Abstain, weight: Decimal::percent(35), }, ], })) } ```

[x/gov]: https://github.com/cosmos/cosmos-sdk/tree/v0.45.12/x/gov
*/
type GovMsg struct {
	// This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.
	Vote *GovMsg_Vote `json:"vote,omitempty"`
}

// In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.
type IbcTimeout struct {
	Block     *IbcTimeoutBlock `json:"block,omitempty"`
	Timestamp *Timestamp       `json:"timestamp,omitempty"`
}

// The params we need to provide for migration msgs
type ProposalParams struct {
	CloseProposalOnExecutionFailure bool           `json:"close_proposal_on_execution_failure"`
	PreProposeInfo                  PreProposeInfo `json:"pre_propose_info"`
}

type cw20_token_list []Addr

type ExecuteMsg_UpdateSubDaos struct {
	ToAdd    []SubDao `json:"to_add"`
	ToRemove []string `json:"to_remove"`
}

/*
The message types of the wasm module.

See https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto
*/
type WasmMsg struct {
	/*
	   Dispatches a call to another contract at a known address (with known ABI).

	   This is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.
	*/
	Execute *WasmMsg_Execute `json:"execute,omitempty"`
	/*
	   Instantiates a new contracts from previously uploaded Wasm code.

	   The contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.

	   This is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.
	*/
	Instantiate *WasmMsg_Instantiate `json:"instantiate,omitempty"`
	/*
	   Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.

	   Only the contract admin (as defined in wasmd), if any, is able to make this call.

	   This is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.
	*/
	Migrate *WasmMsg_Migrate `json:"migrate,omitempty"`
	// Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.
	UpdateAdmin *WasmMsg_UpdateAdmin `json:"update_admin,omitempty"`
	// Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.
	ClearAdmin *WasmMsg_ClearAdmin `json:"clear_admin,omitempty"`
}

type proposal_modules []ProposalModule

type QueryMsg_TotalPowerAtHeight struct {
	Height *int `json:"height,omitempty"`
}

/*
A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.

# Examples

Use `from` to create instances of this and `u128` to get the value out:

``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);

let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);

let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
*/
type Uint128 string

type ExecuteMsg_UpdateConfig struct {
	Config Config `json:"config"`
}

type ExecuteMsg_UpdateCw20List struct {
	ToAdd    []string `json:"to_add"`
	ToRemove []string `json:"to_remove"`
}

/*
The message types of the distribution module.

See https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto
*/
type DistributionMsg struct {
	// This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37). `delegator_address` is automatically filled with the current contract's address.
	SetWithdrawAddress *DistributionMsg_SetWithdrawAddress `json:"set_withdraw_address,omitempty"`
	// This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50). `delegator_address` is automatically filled with the current contract's address.
	WithdrawDelegatorReward *DistributionMsg_WithdrawDelegatorReward `json:"withdraw_delegator_reward,omitempty"`
}

// Top level config type for core module.
type Config struct {
	// A description of the contract.
	Description string `json:"description"`
	// An optional image URL for displaying alongside the contract.
	ImageUrl *string `json:"image_url,omitempty"`
	// The name of the contract.
	Name string `json:"name"`
	// If true the contract will automatically add received cw20 tokens to its treasury.
	AutomaticallyAddCw20S bool `json:"automatically_add_cw20s"`
	// If true the contract will automatically add received cw721 tokens to its treasury.
	AutomaticallyAddCw721S bool `json:"automatically_add_cw721s"`
	// The URI for the DAO as defined by the DAOstar standard <https://daostar.one/EIP>
	DaoUri *string `json:"dao_uri,omitempty"`
}

type MigrateV1ToV2 struct {
	MigrationParams MigrationModuleParams `json:"migration_params"`
	SubDaos         []SubDao              `json:"sub_daos"`
	V1CodeIds       V1CodeIds             `json:"v1_code_ids"`
	V2CodeIds       V2CodeIds             `json:"v2_code_ids"`
}

type QueryMsg_Admin struct{}

type ContractVersion struct {
	// contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing
	Contract string `json:"contract"`
	// version is any string that this implementation knows. It may be simple counter "1", "2". or semantic version on release tags "v0.7.0", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)
	Version string `json:"version"`
}

type ExecuteMsg_UpdateProposalModules struct {
	// NOTE: the pre-propose-base package depends on it being the case that the core module instantiates its proposal module.
	ToAdd     []ModuleInstantiateInfo `json:"to_add"`
	ToDisable []string                `json:"to_disable"`
}

// Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg
type Cw20ReceiveMsg struct {
	Amount Uint128 `json:"amount"`
	Msg    Binary  `json:"msg"`
	Sender string  `json:"sender"`
}

// Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined
type Duration struct {
	Height *Duration_Height `json:"height,omitempty"`
	// Time in seconds
	Time *Duration_Time `json:"time,omitempty"`
}

// Cw721ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg
type Cw721ReceiveMsg struct {
	Msg     Binary `json:"msg"`
	Sender  string `json:"sender"`
	TokenId string `json:"token_id"`
}

type QueryMsg_DumpState struct{}

type QueryMsg_ProposalModules struct {
	StartAfter *string `json:"start_after,omitempty"`
	Limit      *int    `json:"limit,omitempty"`
}

type active_proposal_modules []ProposalModule

type CosmosMsg_for_Empty struct {
	Bank         *CosmosMsg_for_Empty_Bank         `json:"bank,omitempty"`
	Custom       *CosmosMsg_for_Empty_Custom       `json:"custom,omitempty"`
	Staking      *CosmosMsg_for_Empty_Staking      `json:"staking,omitempty"`
	Distribution *CosmosMsg_for_Empty_Distribution `json:"distribution,omitempty"`
	// A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto). This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)
	Stargate *CosmosMsg_for_Empty_Stargate `json:"stargate,omitempty"`
	Ibc      *CosmosMsg_for_Empty_Ibc      `json:"ibc,omitempty"`
	Wasm     *CosmosMsg_for_Empty_Wasm     `json:"wasm,omitempty"`
	Gov      *CosmosMsg_for_Empty_Gov      `json:"gov,omitempty"`
}

// IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)
type IbcTimeoutBlock struct {
	// block height after which the packet times out. the height within the given revision
	Height int `json:"height"`
	// the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)
	Revision int `json:"revision"`
}

type QueryMsg_ListItems struct {
	Limit      *int    `json:"limit,omitempty"`
	StartAfter *string `json:"start_after,omitempty"`
}

// Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)
type Expiration struct {
	// AtHeight will expire when `env.block.height` >= height
	AtHeight *Expiration_AtHeight `json:"at_height,omitempty"`
	// AtTime will expire when `env.block.time` >= time
	AtTime *Expiration_AtTime `json:"at_time,omitempty"`
	// Never will never expire. Used to express the empty variant
	Never *Expiration_Never `json:"never,omitempty"`
}

// Information about if the contract is currently paused.
type PauseInfoResponse struct {
	Paused   *PauseInfoResponse_Paused   `json:"paused,omitempty"`
	Unpaused *PauseInfoResponse_Unpaused `json:"unpaused,omitempty"`
}

type ExecuteMsg_Unpause struct{}

type SubDao struct {
	// The contract address of the SubDAO
	Addr string `json:"addr"`
	// The purpose/constitution for the SubDAO
	Charter *string `json:"charter,omitempty"`
}

type MigrateMsg_FromV1 struct {
	DaoUri *string        `json:"dao_uri,omitempty"`
	Params *MigrateParams `json:"params,omitempty"`
}

type QueryMsg_GetItem struct {
	Key string `json:"key"`
}

type QueryMsg_VotingModule struct{}

// The status of a proposal module.
type ProposalModuleStatus string

const (
	ProposalModuleStatus_Enabled  ProposalModuleStatus = "enabled"
	ProposalModuleStatus_Disabled ProposalModuleStatus = "disabled"
)

type ProposalModuleCountResponse struct {
	// The number of active proposal modules.
	ActiveProposalModuleCount int `json:"active_proposal_module_count"`
	// The total number of proposal modules.
	TotalProposalModuleCount int `json:"total_proposal_module_count"`
}

type PreProposeInfo struct {
	// Anyone may create a proposal free of charge.
	AnyoneMayPropose *PreProposeInfo_AnyoneMayPropose `json:"anyone_may_propose,omitempty"`
	// The module specified in INFO has exclusive rights to proposal creation.
	ModuleMayPropose *PreProposeInfo_ModuleMayPropose `json:"module_may_propose,omitempty"`
}

type TotalPowerAtHeightResponse struct {
	Height int     `json:"height"`
	Power  Uint128 `json:"power"`
}

type list_items []string

type ExecuteMsg_ExecuteAdminMsgs struct {
	Msgs []CosmosMsg_for_Empty `json:"msgs"`
}

type ExecuteMsg_Pause struct {
	Duration Duration `json:"duration"`
}

type MigrateMsg_FromCompatible struct{}

type MigrateParams struct {
	MigratorCodeId int           `json:"migrator_code_id"`
	Params         MigrateV1ToV2 `json:"params"`
}

// Top level config type for core module.
type Config_2 struct {
	// The name of the contract.
	Name string `json:"name"`
	// If true the contract will automatically add received cw20 tokens to its treasury.
	AutomaticallyAddCw20S bool `json:"automatically_add_cw20s"`
	// If true the contract will automatically add received cw721 tokens to its treasury.
	AutomaticallyAddCw721S bool `json:"automatically_add_cw721s"`
	// The URI for the DAO as defined by the DAOstar standard <https://daostar.one/EIP>
	DaoUri *string `json:"dao_uri,omitempty"`
	// A description of the contract.
	Description string `json:"description"`
	// An optional image URL for displaying alongside the contract.
	ImageUrl *string `json:"image_url,omitempty"`
}

type DaoURIResponse struct {
	DaoUri *string `json:"dao_uri,omitempty"`
}

type cw721_token_list []Addr

type Coin struct {
	Amount Uint128 `json:"amount"`
	Denom  string  `json:"denom"`
}

type ExecuteMsg_ExecuteProposalHook struct {
	Msgs []CosmosMsg_for_Empty `json:"msgs"`
}
type ExecuteMsg_Receive Cw20ReceiveMsg

type ExecuteMsg_NominateAdmin struct {
	Admin *string `json:"admin,omitempty"`
}

type ExecuteMsg_AcceptAdminNomination struct{}

type QueryMsg_DaoURI struct{}

type QueryMsg_VotingPowerAtHeight struct {
	Address string `json:"address"`
	Height  *int   `json:"height,omitempty"`
}

// Relevant state for the governance module. Returned by the `DumpState` query.
type DumpStateResponse struct {
	// The governance contract's version.
	Version ContractVersion `json:"version"`
	// The voting module associated with the governance contract.
	VotingModule Addr `json:"voting_module"`
	// The number of active proposal modules.
	ActiveProposalModuleCount int `json:"active_proposal_module_count"`
	// Optional DAO Admin
	Admin Addr `json:"admin"`
	// The governance contract's config.
	Config    Config            `json:"config"`
	PauseInfo PauseInfoResponse `json:"pause_info"`
	// The governance modules associated with the governance contract.
	ProposalModules []ProposalModule `json:"proposal_modules"`
	// The total number of proposal modules.
	TotalProposalModuleCount int `json:"total_proposal_module_count"`
}

// These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts (contracts that directly speak the IBC protocol via 6 entry points)
type IbcMsg struct {
	// Sends bank tokens owned by the contract to the given address on another chain. The channel must already be established between the ibctransfer module on this chain and a matching module on the remote chain. We cannot select the port_id, this is whatever the local chain has bound the ibctransfer module to.
	Transfer *IbcMsg_Transfer `json:"transfer,omitempty"`
	// Sends an IBC packet with given data over the existing channel. Data should be encoded in a format defined by the channel version, and the module on the other side should know how to parse this.
	SendPacket *IbcMsg_SendPacket `json:"send_packet,omitempty"`
	// This will close an existing channel that is owned by this contract. Port is auto-assigned to the contract's IBC port
	CloseChannel *IbcMsg_CloseChannel `json:"close_channel,omitempty"`
}

/*
A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.

# Examples

Use `from` to create instances of this and `u64` to get the value out:

``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);

let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
*/
type Uint64 string

type QueryMsg_Config struct{}

/*
A human readable address.

In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.

This type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.

This type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.
*/
type Addr string

// Returned by the `GetItem` query.
type GetItemResponse struct {
	// `None` if no item with the provided key was found, `Some` otherwise.
	Item *string `json:"item,omitempty"`
}

/*
Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.

This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
*/
type Binary string

// Information about an item to be stored in the items list.
type InitialItem struct {
	// The name of the item.
	Key string `json:"key"`
	// The value the item will have at instantiation time.
	Value string `json:"value"`
}

type ExecuteMsg_WithdrawAdminNomination struct{}

type V1CodeIds struct {
	Cw20StakedBalancesVoting int `json:"cw20_staked_balances_voting"`
	Cw4Voting                int `json:"cw4_voting"`
	ProposalSingle           int `json:"proposal_single"`
	Cw20Stake                int `json:"cw20_stake"`
}

type MigrationModuleParams struct {
	// Rather or not to migrate the stake_cw20 contract and its manager. If this is not set to true and a stake_cw20 contract is detected in the DAO's configuration the migration will be aborted.
	MigrateStakeCw20Manager *bool `json:"migrate_stake_cw20_manager,omitempty"`
	ProposalParams          []any `json:"proposal_params"`
}

type QueryMsg_Cw20TokenList struct {
	Limit      *int    `json:"limit,omitempty"`
	StartAfter *string `json:"start_after,omitempty"`
}

type QueryMsg_PauseInfo struct{}

type WasmMsg_UpdateAdmin struct {
	ContractAddr string `json:"contract_addr"`
	Admin        string `json:"admin"`
}

type pause_info_Paused struct {
	Expiration Expiration `json:"expiration"`
}

type IbcMsg_CloseChannel struct {
	ChannelId string `json:"channel_id"`
}
type CosmosMsg_for_Empty_Distribution DistributionMsg

type WasmMsg_Execute struct {
	ContractAddr string `json:"contract_addr"`
	Funds        []Coin `json:"funds"`
	// msg is the json-encoded ExecuteMsg struct (as raw Binary)
	Msg Binary `json:"msg"`
}

type PauseInfoResponse_Paused struct {
	Expiration Expiration `json:"expiration"`
}
type CosmosMsg_for_Empty_Staking StakingMsg
type CosmosMsg_for_Empty_Ibc IbcMsg

type PreProposeInfo_AnyoneMayPropose struct{}

type Expiration_Never struct{}

type Admin_Address struct {
	Addr string `json:"addr"`
}

type BankMsg_Burn struct {
	Amount []Coin `json:"amount"`
}

type Duration_Height int

type Expiration_AtHeight int

type Admin_CoreModule struct{}
type CosmosMsg_for_Empty_Wasm WasmMsg

type Duration_Time int

type WasmMsg_Migrate struct {
	ContractAddr string `json:"contract_addr"`
	// msg is the json-encoded MigrateMsg struct that will be passed to the new code
	Msg Binary `json:"msg"`
	// the code_id of the new logic to place in the given contract
	NewCodeId int `json:"new_code_id"`
}

type DistributionMsg_SetWithdrawAddress struct {
	// The `withdraw_address`
	Address string `json:"address"`
}

type StakingMsg_Delegate struct {
	Amount    Coin   `json:"amount"`
	Validator string `json:"validator"`
}

type BankMsg_Send struct {
	Amount    []Coin `json:"amount"`
	ToAddress string `json:"to_address"`
}

type IbcMsg_Transfer struct {
	// existing channel to send the tokens over
	ChannelId string `json:"channel_id"`
	// when packet times out, measured on remote chain
	Timeout IbcTimeout `json:"timeout"`
	// address on the remote chain to receive these tokens
	ToAddress string `json:"to_address"`
	// packet data only supports one coin https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20
	Amount Coin `json:"amount"`
}
type CosmosMsg_for_Empty_Custom Empty

type StakingMsg_Undelegate struct {
	Amount    Coin   `json:"amount"`
	Validator string `json:"validator"`
}

type PreProposeInfo_ModuleMayPropose struct {
	Info ModuleInstantiateInfo `json:"info"`
}

type IbcMsg_SendPacket struct {
	ChannelId string `json:"channel_id"`
	Data      Binary `json:"data"`
	// when packet times out, measured on remote chain
	Timeout IbcTimeout `json:"timeout"`
}

type PauseInfoResponse_Unpaused struct{}

type pause_info_Unpaused struct{}

type StakingMsg_Redelegate struct {
	SrcValidator string `json:"src_validator"`
	Amount       Coin   `json:"amount"`
	DstValidator string `json:"dst_validator"`
}

type WasmMsg_ClearAdmin struct {
	ContractAddr string `json:"contract_addr"`
}

type WasmMsg_Instantiate struct {
	/*
	   A human-readable label for the contract.

	   Valid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace
	*/
	Label string `json:"label"`
	// msg is the JSON-encoded InstantiateMsg struct (as raw Binary)
	Msg    Binary  `json:"msg"`
	Admin  *string `json:"admin,omitempty"`
	CodeId int     `json:"code_id"`
	Funds  []Coin  `json:"funds"`
}
type CosmosMsg_for_Empty_Bank BankMsg
type CosmosMsg_for_Empty_Gov GovMsg
type Expiration_AtTime Timestamp

type GovMsg_Vote struct {
	/*
	   The vote option.

	   This should be called "option" for consistency with Cosmos SDK. Sorry for that. See <https://github.com/CosmWasm/cosmwasm/issues/1571>.
	*/
	Vote       VoteOption `json:"vote"`
	ProposalId int        `json:"proposal_id"`
}

type CosmosMsg_for_Empty_Stargate struct {
	TypeUrl string `json:"type_url"`
	Value   Binary `json:"value"`
}

type DistributionMsg_WithdrawDelegatorReward struct {
	// The `validator_address`
	Validator string `json:"validator"`
}
