// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: penumbra/core/stake/v1alpha1/stake.proto

package stakev1alpha1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	v1alpha1 "github.com/strangelove-ventures/interchaintest/v8/chain/penumbra/core/crypto/v1alpha1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BondingState_BondingStateEnum int32

const (
	BondingState_BONDING_STATE_ENUM_UNSPECIFIED BondingState_BondingStateEnum = 0
	BondingState_BONDING_STATE_ENUM_BONDED      BondingState_BondingStateEnum = 1
	BondingState_BONDING_STATE_ENUM_UNBONDING   BondingState_BondingStateEnum = 2
	BondingState_BONDING_STATE_ENUM_UNBONDED    BondingState_BondingStateEnum = 3
)

var BondingState_BondingStateEnum_name = map[int32]string{
	0: "BONDING_STATE_ENUM_UNSPECIFIED",
	1: "BONDING_STATE_ENUM_BONDED",
	2: "BONDING_STATE_ENUM_UNBONDING",
	3: "BONDING_STATE_ENUM_UNBONDED",
}

var BondingState_BondingStateEnum_value = map[string]int32{
	"BONDING_STATE_ENUM_UNSPECIFIED": 0,
	"BONDING_STATE_ENUM_BONDED":      1,
	"BONDING_STATE_ENUM_UNBONDING":   2,
	"BONDING_STATE_ENUM_UNBONDED":    3,
}

func (x BondingState_BondingStateEnum) String() string {
	return proto.EnumName(BondingState_BondingStateEnum_name, int32(x))
}

func (BondingState_BondingStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{6, 0}
}

type ValidatorState_ValidatorStateEnum int32

const (
	ValidatorState_VALIDATOR_STATE_ENUM_UNSPECIFIED ValidatorState_ValidatorStateEnum = 0
	ValidatorState_VALIDATOR_STATE_ENUM_INACTIVE    ValidatorState_ValidatorStateEnum = 1
	ValidatorState_VALIDATOR_STATE_ENUM_ACTIVE      ValidatorState_ValidatorStateEnum = 2
	ValidatorState_VALIDATOR_STATE_ENUM_JAILED      ValidatorState_ValidatorStateEnum = 3
	ValidatorState_VALIDATOR_STATE_ENUM_TOMBSTONED  ValidatorState_ValidatorStateEnum = 4
	ValidatorState_VALIDATOR_STATE_ENUM_DISABLED    ValidatorState_ValidatorStateEnum = 5
)

var ValidatorState_ValidatorStateEnum_name = map[int32]string{
	0: "VALIDATOR_STATE_ENUM_UNSPECIFIED",
	1: "VALIDATOR_STATE_ENUM_INACTIVE",
	2: "VALIDATOR_STATE_ENUM_ACTIVE",
	3: "VALIDATOR_STATE_ENUM_JAILED",
	4: "VALIDATOR_STATE_ENUM_TOMBSTONED",
	5: "VALIDATOR_STATE_ENUM_DISABLED",
}

var ValidatorState_ValidatorStateEnum_value = map[string]int32{
	"VALIDATOR_STATE_ENUM_UNSPECIFIED": 0,
	"VALIDATOR_STATE_ENUM_INACTIVE":    1,
	"VALIDATOR_STATE_ENUM_ACTIVE":      2,
	"VALIDATOR_STATE_ENUM_JAILED":      3,
	"VALIDATOR_STATE_ENUM_TOMBSTONED":  4,
	"VALIDATOR_STATE_ENUM_DISABLED":    5,
}

func (x ValidatorState_ValidatorStateEnum) String() string {
	return proto.EnumName(ValidatorState_ValidatorStateEnum_name, int32(x))
}

func (ValidatorState_ValidatorStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{7, 0}
}

// Describes a validator's configuration data.
type Validator struct {
	// The validator's identity verification key.
	IdentityKey *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	// The validator's consensus pubkey for use in Tendermint (Ed25519).
	ConsensusKey []byte `protobuf:"bytes,2,opt,name=consensus_key,json=consensusKey,proto3" json:"consensus_key,omitempty"`
	// The validator's (human-readable) name.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The validator's website.
	Website string `protobuf:"bytes,4,opt,name=website,proto3" json:"website,omitempty"`
	// The validator's description.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// Whether the validator is enabled or not.
	//
	// Disabled validators cannot be delegated to, and immediately begin unbonding.
	Enabled bool `protobuf:"varint,8,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// A list of funding streams describing the validator's commission.
	FundingStreams []*FundingStream `protobuf:"bytes,6,rep,name=funding_streams,json=fundingStreams,proto3" json:"funding_streams,omitempty"`
	// The sequence number determines which validator data takes priority, and
	// prevents replay attacks.  The chain only accepts new validator definitions
	// with increasing sequence numbers.
	SequenceNumber uint32 `protobuf:"varint,7,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// The validator's governance key.
	GovernanceKey *v1alpha1.GovernanceKey `protobuf:"bytes,9,opt,name=governance_key,json=governanceKey,proto3" json:"governance_key,omitempty"`
}

func (m *Validator) Reset()         { *m = Validator{} }
func (m *Validator) String() string { return proto.CompactTextString(m) }
func (*Validator) ProtoMessage()    {}
func (*Validator) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{0}
}
func (m *Validator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validator.Merge(m, src)
}
func (m *Validator) XXX_Size() int {
	return m.Size()
}
func (m *Validator) XXX_DiscardUnknown() {
	xxx_messageInfo_Validator.DiscardUnknown(m)
}

var xxx_messageInfo_Validator proto.InternalMessageInfo

func (m *Validator) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *Validator) GetConsensusKey() []byte {
	if m != nil {
		return m.ConsensusKey
	}
	return nil
}

func (m *Validator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Validator) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Validator) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Validator) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *Validator) GetFundingStreams() []*FundingStream {
	if m != nil {
		return m.FundingStreams
	}
	return nil
}

func (m *Validator) GetSequenceNumber() uint32 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Validator) GetGovernanceKey() *v1alpha1.GovernanceKey {
	if m != nil {
		return m.GovernanceKey
	}
	return nil
}

// For storing the list of keys of known validators.
type ValidatorList struct {
	ValidatorKeys []*v1alpha1.IdentityKey `protobuf:"bytes,1,rep,name=validator_keys,json=validatorKeys,proto3" json:"validator_keys,omitempty"`
}

func (m *ValidatorList) Reset()         { *m = ValidatorList{} }
func (m *ValidatorList) String() string { return proto.CompactTextString(m) }
func (*ValidatorList) ProtoMessage()    {}
func (*ValidatorList) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{1}
}
func (m *ValidatorList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorList.Merge(m, src)
}
func (m *ValidatorList) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorList) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorList.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorList proto.InternalMessageInfo

func (m *ValidatorList) GetValidatorKeys() []*v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorKeys
	}
	return nil
}

// A portion of a validator's commission.
type FundingStream struct {
	// The recipient of the funding stream.
	//
	// Types that are valid to be assigned to Recipient:
	//	*FundingStream_ToAddress_
	//	*FundingStream_ToDao_
	Recipient isFundingStream_Recipient `protobuf_oneof:"recipient"`
}

func (m *FundingStream) Reset()         { *m = FundingStream{} }
func (m *FundingStream) String() string { return proto.CompactTextString(m) }
func (*FundingStream) ProtoMessage()    {}
func (*FundingStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{2}
}
func (m *FundingStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStream.Merge(m, src)
}
func (m *FundingStream) XXX_Size() int {
	return m.Size()
}
func (m *FundingStream) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStream.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStream proto.InternalMessageInfo

type isFundingStream_Recipient interface {
	isFundingStream_Recipient()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FundingStream_ToAddress_ struct {
	ToAddress *FundingStream_ToAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,oneof" json:"to_address,omitempty"`
}
type FundingStream_ToDao_ struct {
	ToDao *FundingStream_ToDao `protobuf:"bytes,2,opt,name=to_dao,json=toDao,proto3,oneof" json:"to_dao,omitempty"`
}

func (*FundingStream_ToAddress_) isFundingStream_Recipient() {}
func (*FundingStream_ToDao_) isFundingStream_Recipient()     {}

func (m *FundingStream) GetRecipient() isFundingStream_Recipient {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *FundingStream) GetToAddress() *FundingStream_ToAddress {
	if x, ok := m.GetRecipient().(*FundingStream_ToAddress_); ok {
		return x.ToAddress
	}
	return nil
}

func (m *FundingStream) GetToDao() *FundingStream_ToDao {
	if x, ok := m.GetRecipient().(*FundingStream_ToDao_); ok {
		return x.ToDao
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FundingStream) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FundingStream_ToAddress_)(nil),
		(*FundingStream_ToDao_)(nil),
	}
}

type FundingStream_ToAddress struct {
	// The destination address for the funding stream.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The portion of the staking reward for the entire delegation pool
	// allocated to this funding stream, specified in basis points.
	RateBps uint32 `protobuf:"varint,2,opt,name=rate_bps,json=rateBps,proto3" json:"rate_bps,omitempty"`
}

func (m *FundingStream_ToAddress) Reset()         { *m = FundingStream_ToAddress{} }
func (m *FundingStream_ToAddress) String() string { return proto.CompactTextString(m) }
func (*FundingStream_ToAddress) ProtoMessage()    {}
func (*FundingStream_ToAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{2, 0}
}
func (m *FundingStream_ToAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStream_ToAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStream_ToAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStream_ToAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStream_ToAddress.Merge(m, src)
}
func (m *FundingStream_ToAddress) XXX_Size() int {
	return m.Size()
}
func (m *FundingStream_ToAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStream_ToAddress.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStream_ToAddress proto.InternalMessageInfo

func (m *FundingStream_ToAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *FundingStream_ToAddress) GetRateBps() uint32 {
	if m != nil {
		return m.RateBps
	}
	return 0
}

type FundingStream_ToDao struct {
	// The portion of the staking reward for the entire delegation pool
	// allocated to this funding stream, specified in basis points.
	RateBps uint32 `protobuf:"varint,2,opt,name=rate_bps,json=rateBps,proto3" json:"rate_bps,omitempty"`
}

func (m *FundingStream_ToDao) Reset()         { *m = FundingStream_ToDao{} }
func (m *FundingStream_ToDao) String() string { return proto.CompactTextString(m) }
func (*FundingStream_ToDao) ProtoMessage()    {}
func (*FundingStream_ToDao) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{2, 1}
}
func (m *FundingStream_ToDao) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStream_ToDao) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStream_ToDao.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStream_ToDao) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStream_ToDao.Merge(m, src)
}
func (m *FundingStream_ToDao) XXX_Size() int {
	return m.Size()
}
func (m *FundingStream_ToDao) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStream_ToDao.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStream_ToDao proto.InternalMessageInfo

func (m *FundingStream_ToDao) GetRateBps() uint32 {
	if m != nil {
		return m.RateBps
	}
	return 0
}

// Describes the reward and exchange rates and voting power for a validator in some epoch.
type RateData struct {
	IdentityKey           *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	EpochIndex            uint64                `protobuf:"varint,2,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	ValidatorRewardRate   uint64                `protobuf:"varint,4,opt,name=validator_reward_rate,json=validatorRewardRate,proto3" json:"validator_reward_rate,omitempty"`
	ValidatorExchangeRate uint64                `protobuf:"varint,5,opt,name=validator_exchange_rate,json=validatorExchangeRate,proto3" json:"validator_exchange_rate,omitempty"`
}

func (m *RateData) Reset()         { *m = RateData{} }
func (m *RateData) String() string { return proto.CompactTextString(m) }
func (*RateData) ProtoMessage()    {}
func (*RateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{3}
}
func (m *RateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateData.Merge(m, src)
}
func (m *RateData) XXX_Size() int {
	return m.Size()
}
func (m *RateData) XXX_DiscardUnknown() {
	xxx_messageInfo_RateData.DiscardUnknown(m)
}

var xxx_messageInfo_RateData proto.InternalMessageInfo

func (m *RateData) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *RateData) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *RateData) GetValidatorRewardRate() uint64 {
	if m != nil {
		return m.ValidatorRewardRate
	}
	return 0
}

func (m *RateData) GetValidatorExchangeRate() uint64 {
	if m != nil {
		return m.ValidatorExchangeRate
	}
	return 0
}

// Describes the base reward and exchange rates in some epoch.
type BaseRateData struct {
	EpochIndex       uint64 `protobuf:"varint,1,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	BaseRewardRate   uint64 `protobuf:"varint,2,opt,name=base_reward_rate,json=baseRewardRate,proto3" json:"base_reward_rate,omitempty"`
	BaseExchangeRate uint64 `protobuf:"varint,3,opt,name=base_exchange_rate,json=baseExchangeRate,proto3" json:"base_exchange_rate,omitempty"`
}

func (m *BaseRateData) Reset()         { *m = BaseRateData{} }
func (m *BaseRateData) String() string { return proto.CompactTextString(m) }
func (*BaseRateData) ProtoMessage()    {}
func (*BaseRateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{4}
}
func (m *BaseRateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseRateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseRateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseRateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseRateData.Merge(m, src)
}
func (m *BaseRateData) XXX_Size() int {
	return m.Size()
}
func (m *BaseRateData) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseRateData.DiscardUnknown(m)
}

var xxx_messageInfo_BaseRateData proto.InternalMessageInfo

func (m *BaseRateData) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *BaseRateData) GetBaseRewardRate() uint64 {
	if m != nil {
		return m.BaseRewardRate
	}
	return 0
}

func (m *BaseRateData) GetBaseExchangeRate() uint64 {
	if m != nil {
		return m.BaseExchangeRate
	}
	return 0
}

// Describes the current state of a validator on-chain
type ValidatorStatus struct {
	IdentityKey  *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=identity_key,json=identityKey,proto3" json:"identity_key,omitempty"`
	State        *ValidatorState       `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	VotingPower  uint64                `protobuf:"varint,3,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	BondingState *BondingState         `protobuf:"bytes,4,opt,name=bonding_state,json=bondingState,proto3" json:"bonding_state,omitempty"`
}

func (m *ValidatorStatus) Reset()         { *m = ValidatorStatus{} }
func (m *ValidatorStatus) String() string { return proto.CompactTextString(m) }
func (*ValidatorStatus) ProtoMessage()    {}
func (*ValidatorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{5}
}
func (m *ValidatorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorStatus.Merge(m, src)
}
func (m *ValidatorStatus) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorStatus proto.InternalMessageInfo

func (m *ValidatorStatus) GetIdentityKey() *v1alpha1.IdentityKey {
	if m != nil {
		return m.IdentityKey
	}
	return nil
}

func (m *ValidatorStatus) GetState() *ValidatorState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ValidatorStatus) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *ValidatorStatus) GetBondingState() *BondingState {
	if m != nil {
		return m.BondingState
	}
	return nil
}

// Describes the unbonding state of a validator's stake pool.
type BondingState struct {
	State          BondingState_BondingStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.stake.v1alpha1.BondingState_BondingStateEnum" json:"state,omitempty"`
	UnbondingEpoch uint64                        `protobuf:"varint,2,opt,name=unbonding_epoch,json=unbondingEpoch,proto3" json:"unbonding_epoch,omitempty"`
}

func (m *BondingState) Reset()         { *m = BondingState{} }
func (m *BondingState) String() string { return proto.CompactTextString(m) }
func (*BondingState) ProtoMessage()    {}
func (*BondingState) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{6}
}
func (m *BondingState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BondingState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BondingState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BondingState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BondingState.Merge(m, src)
}
func (m *BondingState) XXX_Size() int {
	return m.Size()
}
func (m *BondingState) XXX_DiscardUnknown() {
	xxx_messageInfo_BondingState.DiscardUnknown(m)
}

var xxx_messageInfo_BondingState proto.InternalMessageInfo

func (m *BondingState) GetState() BondingState_BondingStateEnum {
	if m != nil {
		return m.State
	}
	return BondingState_BONDING_STATE_ENUM_UNSPECIFIED
}

func (m *BondingState) GetUnbondingEpoch() uint64 {
	if m != nil {
		return m.UnbondingEpoch
	}
	return 0
}

// Describes the state of a validator
type ValidatorState struct {
	State ValidatorState_ValidatorStateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=penumbra.core.stake.v1alpha1.ValidatorState_ValidatorStateEnum" json:"state,omitempty"`
}

func (m *ValidatorState) Reset()         { *m = ValidatorState{} }
func (m *ValidatorState) String() string { return proto.CompactTextString(m) }
func (*ValidatorState) ProtoMessage()    {}
func (*ValidatorState) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{7}
}
func (m *ValidatorState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorState.Merge(m, src)
}
func (m *ValidatorState) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorState) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorState.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorState proto.InternalMessageInfo

func (m *ValidatorState) GetState() ValidatorState_ValidatorStateEnum {
	if m != nil {
		return m.State
	}
	return ValidatorState_VALIDATOR_STATE_ENUM_UNSPECIFIED
}

// Combines all validator info into a single packet.
type ValidatorInfo struct {
	Validator *Validator       `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	Status    *ValidatorStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	RateData  *RateData        `protobuf:"bytes,3,opt,name=rate_data,json=rateData,proto3" json:"rate_data,omitempty"`
}

func (m *ValidatorInfo) Reset()         { *m = ValidatorInfo{} }
func (m *ValidatorInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfo) ProtoMessage()    {}
func (*ValidatorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{8}
}
func (m *ValidatorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorInfo.Merge(m, src)
}
func (m *ValidatorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorInfo proto.InternalMessageInfo

func (m *ValidatorInfo) GetValidator() *Validator {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *ValidatorInfo) GetStatus() *ValidatorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ValidatorInfo) GetRateData() *RateData {
	if m != nil {
		return m.RateData
	}
	return nil
}

// A transaction action (re)defining a validator.
type ValidatorDefinition struct {
	// The configuration data for the validator.
	Validator *Validator `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator,omitempty"`
	// A signature by the validator's identity key over the validator data.
	AuthSig []byte `protobuf:"bytes,2,opt,name=auth_sig,json=authSig,proto3" json:"auth_sig,omitempty"`
}

func (m *ValidatorDefinition) Reset()         { *m = ValidatorDefinition{} }
func (m *ValidatorDefinition) String() string { return proto.CompactTextString(m) }
func (*ValidatorDefinition) ProtoMessage()    {}
func (*ValidatorDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{9}
}
func (m *ValidatorDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorDefinition.Merge(m, src)
}
func (m *ValidatorDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorDefinition proto.InternalMessageInfo

func (m *ValidatorDefinition) GetValidator() *Validator {
	if m != nil {
		return m.Validator
	}
	return nil
}

func (m *ValidatorDefinition) GetAuthSig() []byte {
	if m != nil {
		return m.AuthSig
	}
	return nil
}

// A transaction action adding stake to a validator's delegation pool.
type Delegate struct {
	// The identity key of the validator to delegate to.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The index of the epoch in which this delegation was performed.
	// The delegation takes effect in the next epoch.
	EpochIndex uint64 `protobuf:"varint,2,opt,name=epoch_index,json=epochIndex,proto3" json:"epoch_index,omitempty"`
	// The delegation amount, in units of unbonded stake.
	// TODO: use flow aggregation to hide this, replacing it with bytes amount_ciphertext;
	UnbondedAmount *v1alpha1.Amount `protobuf:"bytes,3,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The amount of delegation tokens produced by this action.
	//
	// This is implied by the validator's exchange rate in the specified epoch
	// (and should be checked in transaction validation!), but including it allows
	// stateless verification that the transaction is internally consistent.
	DelegationAmount *v1alpha1.Amount `protobuf:"bytes,4,opt,name=delegation_amount,json=delegationAmount,proto3" json:"delegation_amount,omitempty"`
}

func (m *Delegate) Reset()         { *m = Delegate{} }
func (m *Delegate) String() string { return proto.CompactTextString(m) }
func (*Delegate) ProtoMessage()    {}
func (*Delegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{10}
}
func (m *Delegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delegate.Merge(m, src)
}
func (m *Delegate) XXX_Size() int {
	return m.Size()
}
func (m *Delegate) XXX_DiscardUnknown() {
	xxx_messageInfo_Delegate.DiscardUnknown(m)
}

var xxx_messageInfo_Delegate proto.InternalMessageInfo

func (m *Delegate) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *Delegate) GetEpochIndex() uint64 {
	if m != nil {
		return m.EpochIndex
	}
	return 0
}

func (m *Delegate) GetUnbondedAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *Delegate) GetDelegationAmount() *v1alpha1.Amount {
	if m != nil {
		return m.DelegationAmount
	}
	return nil
}

// A transaction action withdrawing stake from a validator's delegation pool.
type Undelegate struct {
	// The identity key of the validator to undelegate from.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The index of the epoch in which this undelegation was performed.
	StartEpochIndex uint64 `protobuf:"varint,2,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	// The amount to undelegate, in units of unbonding tokens.
	UnbondedAmount *v1alpha1.Amount `protobuf:"bytes,3,opt,name=unbonded_amount,json=unbondedAmount,proto3" json:"unbonded_amount,omitempty"`
	// The amount of delegation tokens consumed by this action.
	//
	// This is implied by the validator's exchange rate in the specified epoch
	// (and should be checked in transaction validation!), but including it allows
	// stateless verification that the transaction is internally consistent.
	DelegationAmount *v1alpha1.Amount `protobuf:"bytes,4,opt,name=delegation_amount,json=delegationAmount,proto3" json:"delegation_amount,omitempty"`
}

func (m *Undelegate) Reset()         { *m = Undelegate{} }
func (m *Undelegate) String() string { return proto.CompactTextString(m) }
func (*Undelegate) ProtoMessage()    {}
func (*Undelegate) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{11}
}
func (m *Undelegate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Undelegate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Undelegate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Undelegate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Undelegate.Merge(m, src)
}
func (m *Undelegate) XXX_Size() int {
	return m.Size()
}
func (m *Undelegate) XXX_DiscardUnknown() {
	xxx_messageInfo_Undelegate.DiscardUnknown(m)
}

var xxx_messageInfo_Undelegate proto.InternalMessageInfo

func (m *Undelegate) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *Undelegate) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *Undelegate) GetUnbondedAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondedAmount
	}
	return nil
}

func (m *Undelegate) GetDelegationAmount() *v1alpha1.Amount {
	if m != nil {
		return m.DelegationAmount
	}
	return nil
}

// A transaction action finishing an undelegation, converting (slashable)
// "unbonding tokens" to (unslashable) staking tokens.
type UndelegateClaim struct {
	Body  *UndelegateClaimBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	Proof []byte               `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *UndelegateClaim) Reset()         { *m = UndelegateClaim{} }
func (m *UndelegateClaim) String() string { return proto.CompactTextString(m) }
func (*UndelegateClaim) ProtoMessage()    {}
func (*UndelegateClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{12}
}
func (m *UndelegateClaim) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateClaim.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateClaim.Merge(m, src)
}
func (m *UndelegateClaim) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateClaim.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateClaim proto.InternalMessageInfo

func (m *UndelegateClaim) GetBody() *UndelegateClaimBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *UndelegateClaim) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

type UndelegateClaimBody struct {
	// The identity key of the validator to finish undelegating from.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The epoch in which unbonding began, used to verify the penalty.
	StartEpochIndex uint64 `protobuf:"varint,2,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	// The penalty applied to undelegation, in bps^2 (10e-8).
	// In the happy path (no slashing), this is 0.
	Penalty *Penalty `protobuf:"bytes,3,opt,name=penalty,proto3" json:"penalty,omitempty"`
	// The action's contribution to the transaction's value balance.
	BalanceCommitment *v1alpha1.BalanceCommitment `protobuf:"bytes,4,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment,omitempty"`
}

func (m *UndelegateClaimBody) Reset()         { *m = UndelegateClaimBody{} }
func (m *UndelegateClaimBody) String() string { return proto.CompactTextString(m) }
func (*UndelegateClaimBody) ProtoMessage()    {}
func (*UndelegateClaimBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{13}
}
func (m *UndelegateClaimBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateClaimBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateClaimBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateClaimBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateClaimBody.Merge(m, src)
}
func (m *UndelegateClaimBody) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateClaimBody) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateClaimBody.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateClaimBody proto.InternalMessageInfo

func (m *UndelegateClaimBody) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *UndelegateClaimBody) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *UndelegateClaimBody) GetPenalty() *Penalty {
	if m != nil {
		return m.Penalty
	}
	return nil
}

func (m *UndelegateClaimBody) GetBalanceCommitment() *v1alpha1.BalanceCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return nil
}

type UndelegateClaimPlan struct {
	// The identity key of the validator to finish undelegating from.
	ValidatorIdentity *v1alpha1.IdentityKey `protobuf:"bytes,1,opt,name=validator_identity,json=validatorIdentity,proto3" json:"validator_identity,omitempty"`
	// The epoch in which unbonding began, used to verify the penalty.
	StartEpochIndex uint64 `protobuf:"varint,2,opt,name=start_epoch_index,json=startEpochIndex,proto3" json:"start_epoch_index,omitempty"`
	// The penalty applied to undelegation, in bps^2 (10e-8).
	// In the happy path (no slashing), this is 0.
	Penalty *Penalty `protobuf:"bytes,4,opt,name=penalty,proto3" json:"penalty,omitempty"`
	// The amount of unbonding tokens to claim.
	// This is a bare number because its denom is determined by the preceding data.
	UnbondingAmount *v1alpha1.Amount `protobuf:"bytes,5,opt,name=unbonding_amount,json=unbondingAmount,proto3" json:"unbonding_amount,omitempty"`
	// The blinding factor to use for the balance commitment.
	BalanceBlinding []byte `protobuf:"bytes,6,opt,name=balance_blinding,json=balanceBlinding,proto3" json:"balance_blinding,omitempty"`
	// The first blinding factor to use for the ZK undelegate claim proof.
	ProofBlindingR []byte `protobuf:"bytes,7,opt,name=proof_blinding_r,json=proofBlindingR,proto3" json:"proof_blinding_r,omitempty"`
	// The second blinding factor to use for the ZK undelegate claim proof.
	ProofBlindingS []byte `protobuf:"bytes,8,opt,name=proof_blinding_s,json=proofBlindingS,proto3" json:"proof_blinding_s,omitempty"`
}

func (m *UndelegateClaimPlan) Reset()         { *m = UndelegateClaimPlan{} }
func (m *UndelegateClaimPlan) String() string { return proto.CompactTextString(m) }
func (*UndelegateClaimPlan) ProtoMessage()    {}
func (*UndelegateClaimPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{14}
}
func (m *UndelegateClaimPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegateClaimPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegateClaimPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegateClaimPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegateClaimPlan.Merge(m, src)
}
func (m *UndelegateClaimPlan) XXX_Size() int {
	return m.Size()
}
func (m *UndelegateClaimPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegateClaimPlan.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegateClaimPlan proto.InternalMessageInfo

func (m *UndelegateClaimPlan) GetValidatorIdentity() *v1alpha1.IdentityKey {
	if m != nil {
		return m.ValidatorIdentity
	}
	return nil
}

func (m *UndelegateClaimPlan) GetStartEpochIndex() uint64 {
	if m != nil {
		return m.StartEpochIndex
	}
	return 0
}

func (m *UndelegateClaimPlan) GetPenalty() *Penalty {
	if m != nil {
		return m.Penalty
	}
	return nil
}

func (m *UndelegateClaimPlan) GetUnbondingAmount() *v1alpha1.Amount {
	if m != nil {
		return m.UnbondingAmount
	}
	return nil
}

func (m *UndelegateClaimPlan) GetBalanceBlinding() []byte {
	if m != nil {
		return m.BalanceBlinding
	}
	return nil
}

func (m *UndelegateClaimPlan) GetProofBlindingR() []byte {
	if m != nil {
		return m.ProofBlindingR
	}
	return nil
}

func (m *UndelegateClaimPlan) GetProofBlindingS() []byte {
	if m != nil {
		return m.ProofBlindingS
	}
	return nil
}

// A list of pending delegations and undelegations.
type DelegationChanges struct {
	Delegations   []*Delegate   `protobuf:"bytes,1,rep,name=delegations,proto3" json:"delegations,omitempty"`
	Undelegations []*Undelegate `protobuf:"bytes,2,rep,name=undelegations,proto3" json:"undelegations,omitempty"`
}

func (m *DelegationChanges) Reset()         { *m = DelegationChanges{} }
func (m *DelegationChanges) String() string { return proto.CompactTextString(m) }
func (*DelegationChanges) ProtoMessage()    {}
func (*DelegationChanges) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{15}
}
func (m *DelegationChanges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationChanges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationChanges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationChanges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationChanges.Merge(m, src)
}
func (m *DelegationChanges) XXX_Size() int {
	return m.Size()
}
func (m *DelegationChanges) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationChanges.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationChanges proto.InternalMessageInfo

func (m *DelegationChanges) GetDelegations() []*Delegate {
	if m != nil {
		return m.Delegations
	}
	return nil
}

func (m *DelegationChanges) GetUndelegations() []*Undelegate {
	if m != nil {
		return m.Undelegations
	}
	return nil
}

// Track's a validator's uptime.
type Uptime struct {
	AsOfBlockHeight uint64 `protobuf:"varint,1,opt,name=as_of_block_height,json=asOfBlockHeight,proto3" json:"as_of_block_height,omitempty"`
	WindowLen       uint32 `protobuf:"varint,2,opt,name=window_len,json=windowLen,proto3" json:"window_len,omitempty"`
	Bitvec          []byte `protobuf:"bytes,3,opt,name=bitvec,proto3" json:"bitvec,omitempty"`
}

func (m *Uptime) Reset()         { *m = Uptime{} }
func (m *Uptime) String() string { return proto.CompactTextString(m) }
func (*Uptime) ProtoMessage()    {}
func (*Uptime) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{16}
}
func (m *Uptime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Uptime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Uptime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Uptime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Uptime.Merge(m, src)
}
func (m *Uptime) XXX_Size() int {
	return m.Size()
}
func (m *Uptime) XXX_DiscardUnknown() {
	xxx_messageInfo_Uptime.DiscardUnknown(m)
}

var xxx_messageInfo_Uptime proto.InternalMessageInfo

func (m *Uptime) GetAsOfBlockHeight() uint64 {
	if m != nil {
		return m.AsOfBlockHeight
	}
	return 0
}

func (m *Uptime) GetWindowLen() uint32 {
	if m != nil {
		return m.WindowLen
	}
	return 0
}

func (m *Uptime) GetBitvec() []byte {
	if m != nil {
		return m.Bitvec
	}
	return nil
}

// Tracks our view of Tendermint's view of the validator set, so we can keep it
// from getting confused.
type CurrentConsensusKeys struct {
	ConsensusKeys []*v1alpha1.ConsensusKey `protobuf:"bytes,1,rep,name=consensus_keys,json=consensusKeys,proto3" json:"consensus_keys,omitempty"`
}

func (m *CurrentConsensusKeys) Reset()         { *m = CurrentConsensusKeys{} }
func (m *CurrentConsensusKeys) String() string { return proto.CompactTextString(m) }
func (*CurrentConsensusKeys) ProtoMessage()    {}
func (*CurrentConsensusKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{17}
}
func (m *CurrentConsensusKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentConsensusKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentConsensusKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentConsensusKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentConsensusKeys.Merge(m, src)
}
func (m *CurrentConsensusKeys) XXX_Size() int {
	return m.Size()
}
func (m *CurrentConsensusKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentConsensusKeys.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentConsensusKeys proto.InternalMessageInfo

func (m *CurrentConsensusKeys) GetConsensusKeys() []*v1alpha1.ConsensusKey {
	if m != nil {
		return m.ConsensusKeys
	}
	return nil
}

// Tracks slashing penalties applied to a validator in some epoch.
type Penalty struct {
	Inner uint64 `protobuf:"varint,1,opt,name=inner,proto3" json:"inner,omitempty"`
}

func (m *Penalty) Reset()         { *m = Penalty{} }
func (m *Penalty) String() string { return proto.CompactTextString(m) }
func (*Penalty) ProtoMessage()    {}
func (*Penalty) Descriptor() ([]byte, []int) {
	return fileDescriptor_022d012c8e7b3ca5, []int{18}
}
func (m *Penalty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Penalty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Penalty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Penalty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Penalty.Merge(m, src)
}
func (m *Penalty) XXX_Size() int {
	return m.Size()
}
func (m *Penalty) XXX_DiscardUnknown() {
	xxx_messageInfo_Penalty.DiscardUnknown(m)
}

var xxx_messageInfo_Penalty proto.InternalMessageInfo

func (m *Penalty) GetInner() uint64 {
	if m != nil {
		return m.Inner
	}
	return 0
}

func init() {
	proto.RegisterEnum("penumbra.core.stake.v1alpha1.BondingState_BondingStateEnum", BondingState_BondingStateEnum_name, BondingState_BondingStateEnum_value)
	proto.RegisterEnum("penumbra.core.stake.v1alpha1.ValidatorState_ValidatorStateEnum", ValidatorState_ValidatorStateEnum_name, ValidatorState_ValidatorStateEnum_value)
	proto.RegisterType((*Validator)(nil), "penumbra.core.stake.v1alpha1.Validator")
	proto.RegisterType((*ValidatorList)(nil), "penumbra.core.stake.v1alpha1.ValidatorList")
	proto.RegisterType((*FundingStream)(nil), "penumbra.core.stake.v1alpha1.FundingStream")
	proto.RegisterType((*FundingStream_ToAddress)(nil), "penumbra.core.stake.v1alpha1.FundingStream.ToAddress")
	proto.RegisterType((*FundingStream_ToDao)(nil), "penumbra.core.stake.v1alpha1.FundingStream.ToDao")
	proto.RegisterType((*RateData)(nil), "penumbra.core.stake.v1alpha1.RateData")
	proto.RegisterType((*BaseRateData)(nil), "penumbra.core.stake.v1alpha1.BaseRateData")
	proto.RegisterType((*ValidatorStatus)(nil), "penumbra.core.stake.v1alpha1.ValidatorStatus")
	proto.RegisterType((*BondingState)(nil), "penumbra.core.stake.v1alpha1.BondingState")
	proto.RegisterType((*ValidatorState)(nil), "penumbra.core.stake.v1alpha1.ValidatorState")
	proto.RegisterType((*ValidatorInfo)(nil), "penumbra.core.stake.v1alpha1.ValidatorInfo")
	proto.RegisterType((*ValidatorDefinition)(nil), "penumbra.core.stake.v1alpha1.ValidatorDefinition")
	proto.RegisterType((*Delegate)(nil), "penumbra.core.stake.v1alpha1.Delegate")
	proto.RegisterType((*Undelegate)(nil), "penumbra.core.stake.v1alpha1.Undelegate")
	proto.RegisterType((*UndelegateClaim)(nil), "penumbra.core.stake.v1alpha1.UndelegateClaim")
	proto.RegisterType((*UndelegateClaimBody)(nil), "penumbra.core.stake.v1alpha1.UndelegateClaimBody")
	proto.RegisterType((*UndelegateClaimPlan)(nil), "penumbra.core.stake.v1alpha1.UndelegateClaimPlan")
	proto.RegisterType((*DelegationChanges)(nil), "penumbra.core.stake.v1alpha1.DelegationChanges")
	proto.RegisterType((*Uptime)(nil), "penumbra.core.stake.v1alpha1.Uptime")
	proto.RegisterType((*CurrentConsensusKeys)(nil), "penumbra.core.stake.v1alpha1.CurrentConsensusKeys")
	proto.RegisterType((*Penalty)(nil), "penumbra.core.stake.v1alpha1.Penalty")
}

func init() {
	proto.RegisterFile("penumbra/core/stake/v1alpha1/stake.proto", fileDescriptor_022d012c8e7b3ca5)
}

var fileDescriptor_022d012c8e7b3ca5 = []byte{
	// 1576 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xcd, 0x6f, 0x23, 0x49,
	0x15, 0x4f, 0x77, 0xec, 0x24, 0x7e, 0xfe, 0x4c, 0xcd, 0x02, 0x9e, 0x61, 0x26, 0xf1, 0xf6, 0x02,
	0x63, 0x66, 0x76, 0x6d, 0x26, 0x08, 0x84, 0xb2, 0x87, 0xc5, 0x5f, 0x3b, 0xe3, 0xdd, 0x19, 0xc7,
	0xdb, 0x76, 0x22, 0x81, 0x22, 0xb5, 0xca, 0xee, 0x8a, 0xdd, 0x8c, 0x5d, 0x65, 0xba, 0xca, 0xce,
	0xe6, 0x2f, 0xe0, 0xca, 0x71, 0xcf, 0x48, 0x70, 0x58, 0x09, 0xae, 0x9c, 0x96, 0x33, 0xe2, 0xb4,
	0xdc, 0x38, 0xa2, 0x8c, 0x04, 0x12, 0x7f, 0x05, 0xaa, 0xea, 0xae, 0xf6, 0x47, 0xbe, 0x26, 0xab,
	0x11, 0x1a, 0x4e, 0xf6, 0x7b, 0xef, 0xf7, 0x5e, 0xbd, 0xf7, 0x7b, 0xf5, 0xaa, 0xab, 0x1b, 0x8a,
	0x13, 0x42, 0xa7, 0xe3, 0x9e, 0x8f, 0xcb, 0x7d, 0xe6, 0x93, 0x32, 0x17, 0xf8, 0x25, 0x29, 0xcf,
	0x9e, 0xe0, 0xd1, 0x64, 0x88, 0x9f, 0x04, 0x62, 0x69, 0xe2, 0x33, 0xc1, 0xd0, 0x7d, 0x8d, 0x2c,
	0x49, 0x64, 0x29, 0x30, 0x69, 0xe4, 0xbd, 0x47, 0xcb, 0x71, 0xfa, 0xfe, 0xd9, 0x44, 0xb0, 0x79,
	0xa0, 0x40, 0x0e, 0x22, 0x59, 0x5f, 0xad, 0x43, 0xe2, 0x08, 0x8f, 0x3c, 0x17, 0x0b, 0xe6, 0xa3,
	0x17, 0x90, 0xf2, 0x5c, 0x42, 0x85, 0x27, 0xce, 0x9c, 0x97, 0xe4, 0x2c, 0x6f, 0x14, 0x8c, 0x62,
	0x72, 0xef, 0x51, 0x69, 0x79, 0xb9, 0x30, 0x80, 0x0e, 0x58, 0x6a, 0x86, 0x2e, 0x9f, 0x92, 0x33,
	0x3b, 0xe9, 0xcd, 0x05, 0xf4, 0x1e, 0xa4, 0xfb, 0x8c, 0x72, 0x42, 0xf9, 0x94, 0xab, 0x78, 0x66,
	0xc1, 0x28, 0xa6, 0xec, 0x54, 0xa4, 0x94, 0x20, 0x04, 0x31, 0x8a, 0xc7, 0x24, 0xbf, 0x5e, 0x30,
	0x8a, 0x09, 0x5b, 0xfd, 0x47, 0x79, 0xd8, 0x3c, 0x25, 0x3d, 0xee, 0x09, 0x92, 0x8f, 0x29, 0xb5,
	0x16, 0x51, 0x01, 0x92, 0x2e, 0xe1, 0x7d, 0xdf, 0x9b, 0x08, 0x8f, 0xd1, 0x7c, 0x5c, 0x59, 0x17,
	0x55, 0xd2, 0x97, 0x50, 0xdc, 0x1b, 0x11, 0x37, 0xbf, 0x55, 0x30, 0x8a, 0x5b, 0xb6, 0x16, 0x51,
	0x17, 0xb2, 0x27, 0x53, 0xea, 0x7a, 0x74, 0xe0, 0x70, 0xe1, 0x13, 0x3c, 0xe6, 0xf9, 0x8d, 0xc2,
	0x7a, 0x31, 0xb9, 0xf7, 0xb8, 0x74, 0x1d, 0x9f, 0xa5, 0x8f, 0x03, 0xa7, 0x8e, 0xf2, 0xb1, 0x33,
	0x27, 0x8b, 0x22, 0x47, 0x0f, 0x21, 0xcb, 0xc9, 0xaf, 0xa7, 0x84, 0xf6, 0x89, 0x23, 0x83, 0x10,
	0x3f, 0xbf, 0x59, 0x30, 0x8a, 0x69, 0x3b, 0xa3, 0xd5, 0x2d, 0xa5, 0x45, 0x1d, 0xc8, 0x0c, 0xd8,
	0x8c, 0xf8, 0x14, 0x4b, 0xa8, 0xa4, 0x23, 0xa1, 0xe8, 0x7d, 0xff, 0x06, 0x7a, 0x9f, 0x46, 0x4e,
	0x92, 0xe0, 0xf4, 0x60, 0x51, 0xb4, 0x7a, 0x90, 0x8e, 0xda, 0xf7, 0xdc, 0xe3, 0x02, 0x7d, 0x06,
	0x99, 0x99, 0x56, 0xc8, 0x45, 0x78, 0xde, 0x50, 0x35, 0xde, 0xa6, 0x89, 0xe9, 0x28, 0xc2, 0xa7,
	0xe4, 0x8c, 0x5b, 0x7f, 0x30, 0x21, 0xbd, 0xc4, 0x01, 0x3a, 0x02, 0x10, 0xcc, 0xc1, 0xae, 0xeb,
	0x13, 0xce, 0xc3, 0x5d, 0xf2, 0x93, 0x5b, 0x90, 0x58, 0xea, 0xb2, 0x4a, 0xe0, 0xfc, 0x6c, 0xcd,
	0x4e, 0x08, 0x2d, 0xa0, 0x4f, 0x60, 0x43, 0x30, 0xc7, 0xc5, 0x4c, 0xed, 0x94, 0xe4, 0xde, 0x93,
	0xdb, 0xc5, 0xac, 0x63, 0xf6, 0x6c, 0xcd, 0x8e, 0x0b, 0xf9, 0xe7, 0xde, 0xcf, 0x21, 0x11, 0xad,
	0x22, 0x37, 0xc5, 0x62, 0xb6, 0x09, 0x5b, 0x8b, 0xe8, 0x2e, 0x6c, 0xf9, 0x58, 0x10, 0xa7, 0x37,
	0xe1, 0x6a, 0xd1, 0xb4, 0xbd, 0x29, 0xe5, 0xea, 0x84, 0xdf, 0xb3, 0x20, 0xae, 0x62, 0x5e, 0x83,
	0xa9, 0x26, 0x21, 0xe1, 0x93, 0xbe, 0x37, 0xf1, 0x08, 0x15, 0xd6, 0xbf, 0x0c, 0xd8, 0xb2, 0xb1,
	0x20, 0x75, 0x2c, 0xf0, 0x9b, 0x9e, 0xa5, 0x5d, 0x48, 0x92, 0x09, 0xeb, 0x0f, 0x1d, 0x8f, 0xba,
	0xe4, 0x73, 0x95, 0x46, 0xcc, 0x06, 0xa5, 0x6a, 0x4a, 0x0d, 0xda, 0x83, 0x6f, 0xcd, 0x1b, 0xef,
	0x93, 0x53, 0xec, 0xbb, 0x8e, 0xcc, 0x52, 0x4d, 0x50, 0xcc, 0xbe, 0x13, 0x19, 0x6d, 0x65, 0x93,
	0x79, 0xa2, 0x9f, 0xc2, 0x77, 0xe6, 0x3e, 0xe4, 0xf3, 0xfe, 0x10, 0xd3, 0x01, 0x09, 0xbc, 0xe2,
	0xca, 0x6b, 0x1e, 0xb2, 0x11, 0x5a, 0xa5, 0x9f, 0xf5, 0x1b, 0x03, 0x52, 0x55, 0xcc, 0x49, 0x54,
	0xec, 0x4a, 0x76, 0xc6, 0x85, 0xec, 0x8a, 0x90, 0xeb, 0x61, 0x4e, 0x96, 0x12, 0x0b, 0x6a, 0xc8,
	0x48, 0xfd, 0x42, 0x4e, 0xef, 0x03, 0x52, 0xc8, 0xe5, 0x74, 0xd6, 0x15, 0x56, 0xc5, 0x58, 0xca,
	0xe4, 0x0b, 0x13, 0xb2, 0xd1, 0x00, 0x74, 0x04, 0x16, 0x53, 0xfe, 0xa6, 0x99, 0xaf, 0x42, 0x9c,
	0x0b, 0x9d, 0xef, 0xc5, 0x71, 0x5d, 0xd9, 0x93, 0x4b, 0xc9, 0x10, 0x3b, 0x70, 0x45, 0xef, 0x42,
	0x6a, 0xc6, 0x84, 0x3c, 0x79, 0x26, 0xec, 0x94, 0xf8, 0x61, 0x39, 0xc9, 0x40, 0xd7, 0x96, 0x2a,
	0x74, 0x00, 0xe9, 0x1e, 0xd3, 0xa7, 0x93, 0xee, 0xdb, 0xc5, 0xb4, 0x57, 0x96, 0xab, 0xb2, 0x70,
	0x04, 0xe4, 0x62, 0xa9, 0xde, 0x82, 0x64, 0xfd, 0xde, 0x84, 0xd4, 0xa2, 0x19, 0x7d, 0xa6, 0x0b,
	0x91, 0x84, 0x64, 0xf6, 0x3e, 0x7c, 0xfd, 0xc8, 0x4b, 0x42, 0x83, 0x4e, 0xc7, 0xba, 0xae, 0x87,
	0x90, 0x9d, 0x52, 0x9d, 0xb6, 0x6a, 0xb7, 0xee, 0x6a, 0xa4, 0x6e, 0x48, 0xad, 0xf5, 0x85, 0x01,
	0xb9, 0xd5, 0x20, 0xc8, 0x82, 0x9d, 0xea, 0x41, 0xab, 0xde, 0x6c, 0x3d, 0x75, 0x3a, 0xdd, 0x4a,
	0xb7, 0xe1, 0x34, 0x5a, 0x87, 0x2f, 0x9c, 0xc3, 0x56, 0xa7, 0xdd, 0xa8, 0x35, 0x3f, 0x6e, 0x36,
	0xea, 0xb9, 0x35, 0xf4, 0x00, 0xee, 0x5e, 0x82, 0x91, 0xaa, 0x46, 0x3d, 0x67, 0xa0, 0x02, 0xdc,
	0xbf, 0x34, 0x44, 0xa8, 0xcc, 0x99, 0x68, 0x17, 0xbe, 0x7b, 0x25, 0xa2, 0x51, 0xcf, 0xad, 0x5b,
	0x7f, 0x37, 0x21, 0xb3, 0xdc, 0x35, 0x74, 0xb8, 0xcc, 0xd4, 0x47, 0xb7, 0x69, 0xf9, 0x8a, 0xb8,
	0xc0, 0x96, 0xf5, 0x6f, 0x03, 0xd0, 0x45, 0x2b, 0xfa, 0x1e, 0x14, 0x8e, 0x2a, 0xcf, 0x9b, 0xf5,
	0x4a, 0xf7, 0xc0, 0xbe, 0x9a, 0x88, 0x77, 0xe1, 0xc1, 0xa5, 0xa8, 0x66, 0xab, 0x52, 0xeb, 0x36,
	0x8f, 0x1a, 0x39, 0x43, 0x96, 0x7a, 0x29, 0x24, 0x04, 0x98, 0x57, 0x02, 0x3e, 0xa9, 0x34, 0x9f,
	0x4b, 0x2e, 0xd0, 0x7b, 0xb0, 0x7b, 0x29, 0xa0, 0x7b, 0xf0, 0xa2, 0xda, 0xe9, 0x1e, 0xb4, 0x1a,
	0xf5, 0x5c, 0xec, 0xca, 0x4c, 0xea, 0xcd, 0x4e, 0xa5, 0x2a, 0xe3, 0xc4, 0xad, 0x73, 0x63, 0xe1,
	0xb9, 0xd4, 0xa4, 0x27, 0x0c, 0x35, 0x20, 0x11, 0x9d, 0x25, 0xe1, 0x44, 0x3e, 0x7c, 0x4d, 0x5a,
	0xed, 0xb9, 0x27, 0x6a, 0xc0, 0x06, 0x57, 0x53, 0x1e, 0x4e, 0xe3, 0x07, 0xb7, 0x68, 0xcd, 0x94,
	0xdb, 0xa1, 0x33, 0xaa, 0x41, 0x42, 0x9d, 0xe8, 0x2e, 0x16, 0x58, 0x0d, 0x63, 0x72, 0xef, 0x07,
	0xd7, 0x47, 0xd2, 0x47, 0x9d, 0xad, 0x1e, 0x05, 0xf2, 0x9f, 0x75, 0x0a, 0x77, 0xa2, 0xf8, 0x75,
	0x72, 0xe2, 0x51, 0x4f, 0x5d, 0x40, 0xde, 0x50, 0xa5, 0x77, 0x61, 0x0b, 0x4f, 0xc5, 0xd0, 0xe1,
	0xde, 0x20, 0xbc, 0x37, 0x6d, 0x4a, 0xb9, 0xe3, 0x0d, 0xac, 0x2f, 0x4d, 0xd8, 0xaa, 0x93, 0x11,
	0x19, 0xc8, 0xbd, 0xfa, 0x0b, 0x40, 0xf3, 0x33, 0x5c, 0x9f, 0x5b, 0xdf, 0xe0, 0xcc, 0xdb, 0x8e,
	0xa2, 0x68, 0xed, 0xcd, 0xcf, 0x9c, 0x96, 0x1e, 0x7f, 0xe2, 0x3a, 0x78, 0xcc, 0xa6, 0x54, 0x84,
	0x64, 0x7e, 0xff, 0x86, 0x85, 0x2b, 0x0a, 0xac, 0x4f, 0x09, 0xe2, 0x06, 0x32, 0xb2, 0x61, 0xdb,
	0x0d, 0xea, 0xf2, 0x18, 0xd5, 0x11, 0x63, 0xb7, 0x89, 0x98, 0x9b, 0xfb, 0x07, 0x1a, 0xeb, 0xcf,
	0x26, 0xc0, 0x21, 0x75, 0xff, 0x07, 0x74, 0x3d, 0x82, 0x6d, 0x2e, 0xb0, 0x2f, 0x9c, 0x8b, 0xa4,
	0x65, 0x95, 0xa1, 0xf1, 0xff, 0xc5, 0x1c, 0x85, 0xec, 0x9c, 0xb8, 0xda, 0x08, 0x7b, 0x63, 0xd4,
	0x80, 0x58, 0x8f, 0xb9, 0x9a, 0xaf, 0x1b, 0xae, 0x67, 0x2b, 0xce, 0x55, 0xe6, 0x9e, 0xd9, 0xca,
	0x1d, 0xbd, 0x03, 0xf1, 0x89, 0xcf, 0xd8, 0x49, 0xb8, 0xb1, 0x03, 0xc1, 0xfa, 0x8b, 0x09, 0x77,
	0x2e, 0xf1, 0x79, 0x5b, 0x5a, 0xf6, 0x11, 0x6c, 0x4e, 0x08, 0xc5, 0x23, 0x71, 0x76, 0x45, 0xab,
	0x56, 0xca, 0x6f, 0x07, 0x60, 0x5b, 0x7b, 0x21, 0x47, 0xde, 0x6c, 0x46, 0xea, 0xf6, 0xdf, 0x67,
	0xe3, 0xb1, 0x27, 0xc6, 0x24, 0x6a, 0xd2, 0x8f, 0x6e, 0xa8, 0xa3, 0x1a, 0x38, 0xd6, 0x22, 0x3f,
	0x7b, 0xbb, 0xb7, 0xaa, 0xb2, 0xfe, 0xb4, 0x7e, 0x81, 0xc0, 0xf6, 0x08, 0xd3, 0xb7, 0x90, 0xc0,
	0xd8, 0x37, 0x22, 0xb0, 0x0d, 0xb9, 0xf9, 0x6d, 0x23, 0xdc, 0xe3, 0xf1, 0xdb, 0xec, 0xf1, 0xf9,
	0x65, 0x25, 0x1c, 0x9b, 0x1f, 0xca, 0x6b, 0x69, 0xd0, 0x92, 0xde, 0xc8, 0x53, 0x96, 0xfc, 0x86,
	0xda, 0x93, 0xd9, 0x50, 0x5f, 0x0d, 0xd5, 0xf2, 0x06, 0xab, 0xb6, 0x69, 0x04, 0x74, 0x82, 0x17,
	0xbd, 0x94, 0x9d, 0x51, 0x7a, 0x0d, 0xb4, 0x2f, 0x41, 0x72, 0xf5, 0x2a, 0xba, 0x8a, 0xec, 0x58,
	0x7f, 0x34, 0x60, 0xbb, 0x1e, 0x8d, 0x5d, 0x4d, 0x5d, 0x6b, 0x39, 0x7a, 0x26, 0xdf, 0x71, 0xb5,
	0x52, 0xbf, 0xbf, 0xdd, 0xf0, 0x78, 0xd2, 0x8f, 0x03, 0x7b, 0xd1, 0x15, 0xb5, 0x20, 0x3d, 0xa5,
	0x8b, 0xb1, 0x4c, 0x15, 0xab, 0xf8, 0xba, 0x73, 0x6b, 0x2f, 0xbb, 0x5b, 0x23, 0xd8, 0x38, 0x9c,
	0x08, 0x6f, 0x4c, 0xd0, 0x63, 0x40, 0x98, 0x3b, 0xaa, 0x46, 0xd6, 0x7f, 0xe9, 0x0c, 0x89, 0x37,
	0x18, 0x8a, 0xf0, 0xde, 0x9f, 0xc5, 0xfc, 0xe0, 0xa4, 0x2a, 0xf5, 0xcf, 0x94, 0x1a, 0x3d, 0x00,
	0x38, 0xf5, 0xa8, 0xcb, 0x4e, 0x9d, 0x11, 0xa1, 0xe1, 0x1b, 0x54, 0x22, 0xd0, 0x3c, 0x27, 0x14,
	0x7d, 0x1b, 0x36, 0x7a, 0x9e, 0x98, 0x91, 0xbe, 0x9a, 0xab, 0x94, 0x1d, 0x4a, 0xd6, 0xaf, 0xe0,
	0x9d, 0xda, 0xd4, 0xf7, 0x09, 0x15, 0xb5, 0x85, 0x0f, 0x06, 0x1c, 0xd9, 0x90, 0x59, 0xfa, 0xac,
	0xa0, 0x29, 0x7a, 0x7c, 0xc3, 0x26, 0x58, 0x8c, 0x62, 0xa7, 0x17, 0x3f, 0x42, 0x70, 0x6b, 0x17,
	0x36, 0xc3, 0xed, 0x26, 0x0f, 0x27, 0x8f, 0x52, 0xe2, 0x87, 0xd5, 0x04, 0x42, 0xf5, 0x2b, 0xf3,
	0xaf, 0xe7, 0x3b, 0xc6, 0xd7, 0xe7, 0x3b, 0xc6, 0x3f, 0xcf, 0x77, 0x8c, 0xdf, 0xbe, 0xda, 0x59,
	0xfb, 0xfa, 0xd5, 0xce, 0xda, 0x3f, 0x5e, 0xed, 0xac, 0x41, 0xa1, 0xcf, 0xc6, 0xd7, 0x32, 0x5a,
	0x85, 0x8e, 0x94, 0xdb, 0x3e, 0x13, 0xac, 0x6d, 0xfc, 0xb2, 0x37, 0xf0, 0xc4, 0x70, 0xda, 0x2b,
	0xf5, 0xd9, 0xb8, 0xcc, 0x85, 0x2f, 0x9b, 0x3e, 0x62, 0x33, 0xf2, 0xc1, 0x8c, 0x50, 0x31, 0xf5,
	0x09, 0x2f, 0x7b, 0x54, 0x10, 0xbf, 0x3f, 0xc4, 0xf2, 0x97, 0x8b, 0xf2, 0xec, 0x67, 0x65, 0x25,
	0x94, 0xaf, 0xfb, 0x3e, 0xf4, 0xa1, 0x12, 0xb5, 0xf4, 0x3b, 0x73, 0xbd, 0x5d, 0xeb, 0x7c, 0x69,
	0xde, 0x6f, 0xeb, 0xb4, 0x6a, 0x32, 0x2d, 0x95, 0x46, 0xe9, 0x28, 0x04, 0xfd, 0x6d, 0x6e, 0x3e,
	0x96, 0xe6, 0x63, 0x65, 0x3e, 0xd6, 0xe6, 0x73, 0xb3, 0x78, 0x9d, 0xf9, 0xf8, 0x69, 0xbb, 0xfa,
	0x82, 0x08, 0x2c, 0xaf, 0x50, 0xff, 0x31, 0x77, 0x35, 0x74, 0x7f, 0x5f, 0x62, 0xf7, 0xf7, 0x15,
	0x78, 0x7f, 0x5f, 0xa3, 0x7b, 0x1b, 0xea, 0x7b, 0xd3, 0x8f, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff,
	0x26, 0x3e, 0xf0, 0x37, 0xe5, 0x12, 0x00, 0x00,
}

func (m *Validator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Validator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GovernanceKey != nil {
		{
			size, err := m.GovernanceKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FundingStreams) > 0 {
		for iNdEx := len(m.FundingStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FundingStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConsensusKey) > 0 {
		i -= len(m.ConsensusKey)
		copy(dAtA[i:], m.ConsensusKey)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ConsensusKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidatorKeys) > 0 {
		for iNdEx := len(m.ValidatorKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FundingStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Recipient != nil {
		{
			size := m.Recipient.Size()
			i -= size
			if _, err := m.Recipient.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FundingStream_ToAddress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToAddress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ToAddress != nil {
		{
			size, err := m.ToAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FundingStream_ToDao_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToDao_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ToDao != nil {
		{
			size, err := m.ToDao.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FundingStream_ToAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStream_ToAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateBps != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.RateBps))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundingStream_ToDao) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStream_ToDao) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStream_ToDao) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateBps != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.RateBps))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *RateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorExchangeRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.ValidatorExchangeRate))
		i--
		dAtA[i] = 0x28
	}
	if m.ValidatorRewardRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.ValidatorRewardRate))
		i--
		dAtA[i] = 0x20
	}
	if m.EpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseRateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseRateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseRateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BaseExchangeRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.BaseExchangeRate))
		i--
		dAtA[i] = 0x18
	}
	if m.BaseRewardRate != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.BaseRewardRate))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BondingState != nil {
		{
			size, err := m.BondingState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VotingPower != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IdentityKey != nil {
		{
			size, err := m.IdentityKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BondingState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BondingState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BondingState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnbondingEpoch != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.UnbondingEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.State != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateData != nil {
		{
			size, err := m.RateData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Validator != nil {
		{
			size, err := m.Validator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthSig) > 0 {
		i -= len(m.AuthSig)
		copy(dAtA[i:], m.AuthSig)
		i = encodeVarintStake(dAtA, i, uint64(len(m.AuthSig)))
		i--
		dAtA[i] = 0x12
	}
	if m.Validator != nil {
		{
			size, err := m.Validator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Delegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegationAmount != nil {
		{
			size, err := m.DelegationAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.EpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Undelegate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Undelegate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Undelegate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DelegationAmount != nil {
		{
			size, err := m.DelegationAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UnbondedAmount != nil {
		{
			size, err := m.UnbondedAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateClaim) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateClaim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateClaim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateClaimBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateClaimBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateClaimBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BalanceCommitment != nil {
		{
			size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Penalty != nil {
		{
			size, err := m.Penalty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegateClaimPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegateClaimPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegateClaimPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofBlindingS) > 0 {
		i -= len(m.ProofBlindingS)
		copy(dAtA[i:], m.ProofBlindingS)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ProofBlindingS)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ProofBlindingR) > 0 {
		i -= len(m.ProofBlindingR)
		copy(dAtA[i:], m.ProofBlindingR)
		i = encodeVarintStake(dAtA, i, uint64(len(m.ProofBlindingR)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BalanceBlinding) > 0 {
		i -= len(m.BalanceBlinding)
		copy(dAtA[i:], m.BalanceBlinding)
		i = encodeVarintStake(dAtA, i, uint64(len(m.BalanceBlinding)))
		i--
		dAtA[i] = 0x32
	}
	if m.UnbondingAmount != nil {
		{
			size, err := m.UnbondingAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Penalty != nil {
		{
			size, err := m.Penalty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StartEpochIndex != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.StartEpochIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidatorIdentity != nil {
		{
			size, err := m.ValidatorIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegationChanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationChanges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationChanges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Undelegations) > 0 {
		for iNdEx := len(m.Undelegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Undelegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Delegations) > 0 {
		for iNdEx := len(m.Delegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Uptime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Uptime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Uptime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bitvec) > 0 {
		i -= len(m.Bitvec)
		copy(dAtA[i:], m.Bitvec)
		i = encodeVarintStake(dAtA, i, uint64(len(m.Bitvec)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WindowLen != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.WindowLen))
		i--
		dAtA[i] = 0x10
	}
	if m.AsOfBlockHeight != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.AsOfBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CurrentConsensusKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentConsensusKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentConsensusKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsensusKeys) > 0 {
		for iNdEx := len(m.ConsensusKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsensusKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStake(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Penalty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Penalty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Penalty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Inner != 0 {
		i = encodeVarintStake(dAtA, i, uint64(m.Inner))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStake(dAtA []byte, offset int, v uint64) int {
	offset -= sovStake(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Validator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.ConsensusKey)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if len(m.FundingStreams) > 0 {
		for _, e := range m.FundingStreams {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovStake(uint64(m.SequenceNumber))
	}
	if m.Enabled {
		n += 2
	}
	if m.GovernanceKey != nil {
		l = m.GovernanceKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ValidatorKeys) > 0 {
		for _, e := range m.ValidatorKeys {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func (m *FundingStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Recipient != nil {
		n += m.Recipient.Size()
	}
	return n
}

func (m *FundingStream_ToAddress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToAddress != nil {
		l = m.ToAddress.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}
func (m *FundingStream_ToDao_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToDao != nil {
		l = m.ToDao.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}
func (m *FundingStream_ToAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	if m.RateBps != 0 {
		n += 1 + sovStake(uint64(m.RateBps))
	}
	return n
}

func (m *FundingStream_ToDao) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RateBps != 0 {
		n += 1 + sovStake(uint64(m.RateBps))
	}
	return n
}

func (m *RateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.EpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EpochIndex))
	}
	if m.ValidatorRewardRate != 0 {
		n += 1 + sovStake(uint64(m.ValidatorRewardRate))
	}
	if m.ValidatorExchangeRate != 0 {
		n += 1 + sovStake(uint64(m.ValidatorExchangeRate))
	}
	return n
}

func (m *BaseRateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EpochIndex))
	}
	if m.BaseRewardRate != 0 {
		n += 1 + sovStake(uint64(m.BaseRewardRate))
	}
	if m.BaseExchangeRate != 0 {
		n += 1 + sovStake(uint64(m.BaseExchangeRate))
	}
	return n
}

func (m *ValidatorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdentityKey != nil {
		l = m.IdentityKey.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.VotingPower != 0 {
		n += 1 + sovStake(uint64(m.VotingPower))
	}
	if m.BondingState != nil {
		l = m.BondingState.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *BondingState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovStake(uint64(m.State))
	}
	if m.UnbondingEpoch != 0 {
		n += 1 + sovStake(uint64(m.UnbondingEpoch))
	}
	return n
}

func (m *ValidatorState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovStake(uint64(m.State))
	}
	return n
}

func (m *ValidatorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.RateData != nil {
		l = m.RateData.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *ValidatorDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.AuthSig)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *Delegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.EpochIndex != 0 {
		n += 1 + sovStake(uint64(m.EpochIndex))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.DelegationAmount != nil {
		l = m.DelegationAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *Undelegate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.UnbondedAmount != nil {
		l = m.UnbondedAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.DelegationAmount != nil {
		l = m.DelegationAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *UndelegateClaim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *UndelegateClaimBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.Penalty != nil {
		l = m.Penalty.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.BalanceCommitment != nil {
		l = m.BalanceCommitment.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *UndelegateClaimPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidatorIdentity != nil {
		l = m.ValidatorIdentity.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.StartEpochIndex != 0 {
		n += 1 + sovStake(uint64(m.StartEpochIndex))
	}
	if m.Penalty != nil {
		l = m.Penalty.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	if m.UnbondingAmount != nil {
		l = m.UnbondingAmount.Size()
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.BalanceBlinding)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.ProofBlindingR)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	l = len(m.ProofBlindingS)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *DelegationChanges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Delegations) > 0 {
		for _, e := range m.Delegations {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	if len(m.Undelegations) > 0 {
		for _, e := range m.Undelegations {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func (m *Uptime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsOfBlockHeight != 0 {
		n += 1 + sovStake(uint64(m.AsOfBlockHeight))
	}
	if m.WindowLen != 0 {
		n += 1 + sovStake(uint64(m.WindowLen))
	}
	l = len(m.Bitvec)
	if l > 0 {
		n += 1 + l + sovStake(uint64(l))
	}
	return n
}

func (m *CurrentConsensusKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConsensusKeys) > 0 {
		for _, e := range m.ConsensusKeys {
			l = e.Size()
			n += 1 + l + sovStake(uint64(l))
		}
	}
	return n
}

func (m *Penalty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != 0 {
		n += 1 + sovStake(uint64(m.Inner))
	}
	return n
}

func sovStake(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStake(x uint64) (n int) {
	return sovStake(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Validator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusKey = append(m.ConsensusKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsensusKey == nil {
				m.ConsensusKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FundingStreams = append(m.FundingStreams, &FundingStream{})
			if err := m.FundingStreams[len(m.FundingStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GovernanceKey == nil {
				m.GovernanceKey = &v1alpha1.GovernanceKey{}
			}
			if err := m.GovernanceKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorKeys = append(m.ValidatorKeys, &v1alpha1.IdentityKey{})
			if err := m.ValidatorKeys[len(m.ValidatorKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FundingStream_ToAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Recipient = &FundingStream_ToAddress_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDao", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FundingStream_ToDao{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Recipient = &FundingStream_ToDao_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStream_ToAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateBps", wireType)
			}
			m.RateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStream_ToDao) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToDao: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToDao: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateBps", wireType)
			}
			m.RateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorRewardRate", wireType)
			}
			m.ValidatorRewardRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorRewardRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorExchangeRate", wireType)
			}
			m.ValidatorExchangeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorExchangeRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseRateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseRateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseRateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRewardRate", wireType)
			}
			m.BaseRewardRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRewardRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseExchangeRate", wireType)
			}
			m.BaseExchangeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseExchangeRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityKey == nil {
				m.IdentityKey = &v1alpha1.IdentityKey{}
			}
			if err := m.IdentityKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ValidatorState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondingState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BondingState == nil {
				m.BondingState = &BondingState{}
			}
			if err := m.BondingState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BondingState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BondingState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BondingState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BondingState_BondingStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingEpoch", wireType)
			}
			m.UnbondingEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ValidatorState_ValidatorStateEnum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &Validator{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ValidatorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RateData == nil {
				m.RateData = &RateData{}
			}
			if err := m.RateData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &Validator{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthSig = append(m.AuthSig[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthSig == nil {
				m.AuthSig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIndex", wireType)
			}
			m.EpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegationAmount == nil {
				m.DelegationAmount = &v1alpha1.Amount{}
			}
			if err := m.DelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Undelegate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Undelegate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Undelegate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondedAmount == nil {
				m.UnbondedAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelegationAmount == nil {
				m.DelegationAmount = &v1alpha1.Amount{}
			}
			if err := m.DelegationAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateClaim) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &UndelegateClaimBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateClaimBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateClaimBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateClaimBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Penalty == nil {
				m.Penalty = &Penalty{}
			}
			if err := m.Penalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BalanceCommitment == nil {
				m.BalanceCommitment = &v1alpha1.BalanceCommitment{}
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegateClaimPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegateClaimPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegateClaimPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorIdentity == nil {
				m.ValidatorIdentity = &v1alpha1.IdentityKey{}
			}
			if err := m.ValidatorIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpochIndex", wireType)
			}
			m.StartEpochIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpochIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Penalty == nil {
				m.Penalty = &Penalty{}
			}
			if err := m.Penalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondingAmount == nil {
				m.UnbondingAmount = &v1alpha1.Amount{}
			}
			if err := m.UnbondingAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceBlinding", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceBlinding = append(m.BalanceBlinding[:0], dAtA[iNdEx:postIndex]...)
			if m.BalanceBlinding == nil {
				m.BalanceBlinding = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingR = append(m.ProofBlindingR[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingR == nil {
				m.ProofBlindingR = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofBlindingS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofBlindingS = append(m.ProofBlindingS[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofBlindingS == nil {
				m.ProofBlindingS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationChanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationChanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationChanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegations = append(m.Delegations, &Delegate{})
			if err := m.Delegations[len(m.Delegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Undelegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Undelegations = append(m.Undelegations, &Undelegate{})
			if err := m.Undelegations[len(m.Undelegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Uptime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Uptime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Uptime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfBlockHeight", wireType)
			}
			m.AsOfBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfBlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowLen", wireType)
			}
			m.WindowLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitvec", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bitvec = append(m.Bitvec[:0], dAtA[iNdEx:postIndex]...)
			if m.Bitvec == nil {
				m.Bitvec = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentConsensusKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentConsensusKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentConsensusKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusKeys = append(m.ConsensusKeys, &v1alpha1.ConsensusKey{})
			if err := m.ConsensusKeys[len(m.ConsensusKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Penalty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Penalty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Penalty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			m.Inner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inner |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStake(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStake
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStake
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStake
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStake
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStake        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStake          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStake = fmt.Errorf("proto: unexpected end of group")
)
